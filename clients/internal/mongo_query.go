// Code generated by mockery v1.0.0. DO NOT EDIT.

package internal

import mgo "github.com/globalsign/mgo"
import mock "github.com/stretchr/testify/mock"
import time "time"

// MongoQuery is an autogenerated mock type for the MongoQuery type
type MongoQuery struct {
	mock.Mock
}

// All provides a mock function with given fields: result
func (_m *MongoQuery) All(result interface{}) error {
	ret := _m.Called(result)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Apply provides a mock function with given fields: change, result
func (_m *MongoQuery) Apply(change mgo.Change, result interface{}) (*mgo.ChangeInfo, error) {
	ret := _m.Called(change, result)

	var r0 *mgo.ChangeInfo
	if rf, ok := ret.Get(0).(func(mgo.Change, interface{}) *mgo.ChangeInfo); ok {
		r0 = rf(change, result)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.ChangeInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(mgo.Change, interface{}) error); ok {
		r1 = rf(change, result)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Batch provides a mock function with given fields: n
func (_m *MongoQuery) Batch(n int) *mgo.Query {
	ret := _m.Called(n)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(int) *mgo.Query); ok {
		r0 = rf(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Collation provides a mock function with given fields: collation
func (_m *MongoQuery) Collation(collation *mgo.Collation) *mgo.Query {
	ret := _m.Called(collation)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(*mgo.Collation) *mgo.Query); ok {
		r0 = rf(collation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Comment provides a mock function with given fields: comment
func (_m *MongoQuery) Comment(comment string) *mgo.Query {
	ret := _m.Called(comment)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(string) *mgo.Query); ok {
		r0 = rf(comment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Count provides a mock function with given fields:
func (_m *MongoQuery) Count() (int, error) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Distinct provides a mock function with given fields: key, result
func (_m *MongoQuery) Distinct(key string, result interface{}) error {
	ret := _m.Called(key, result)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(key, result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Explain provides a mock function with given fields: result
func (_m *MongoQuery) Explain(result interface{}) error {
	ret := _m.Called(result)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// For provides a mock function with given fields: result, f
func (_m *MongoQuery) For(result interface{}, f func() error) error {
	ret := _m.Called(result, f)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, func() error) error); ok {
		r0 = rf(result, f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Hint provides a mock function with given fields: indexKey
func (_m *MongoQuery) Hint(indexKey ...string) *mgo.Query {
	_va := make([]interface{}, len(indexKey))
	for _i := range indexKey {
		_va[_i] = indexKey[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(...string) *mgo.Query); ok {
		r0 = rf(indexKey...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Iter provides a mock function with given fields:
func (_m *MongoQuery) Iter() *mgo.Iter {
	ret := _m.Called()

	var r0 *mgo.Iter
	if rf, ok := ret.Get(0).(func() *mgo.Iter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Iter)
		}
	}

	return r0
}

// Limit provides a mock function with given fields: n
func (_m *MongoQuery) Limit(n int) *mgo.Query {
	ret := _m.Called(n)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(int) *mgo.Query); ok {
		r0 = rf(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// LogReplay provides a mock function with given fields:
func (_m *MongoQuery) LogReplay() *mgo.Query {
	ret := _m.Called()

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func() *mgo.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// MapReduce provides a mock function with given fields: job, result
func (_m *MongoQuery) MapReduce(job *mgo.MapReduce, result interface{}) (*mgo.MapReduceInfo, error) {
	ret := _m.Called(job, result)

	var r0 *mgo.MapReduceInfo
	if rf, ok := ret.Get(0).(func(*mgo.MapReduce, interface{}) *mgo.MapReduceInfo); ok {
		r0 = rf(job, result)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.MapReduceInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*mgo.MapReduce, interface{}) error); ok {
		r1 = rf(job, result)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// One provides a mock function with given fields: result
func (_m *MongoQuery) One(result interface{}) error {
	ret := _m.Called(result)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(result)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Prefetch provides a mock function with given fields: p
func (_m *MongoQuery) Prefetch(p float64) *mgo.Query {
	ret := _m.Called(p)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(float64) *mgo.Query); ok {
		r0 = rf(p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Select provides a mock function with given fields: selector
func (_m *MongoQuery) Select(selector interface{}) *mgo.Query {
	ret := _m.Called(selector)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(interface{}) *mgo.Query); ok {
		r0 = rf(selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// SetMaxScan provides a mock function with given fields: n
func (_m *MongoQuery) SetMaxScan(n int) *mgo.Query {
	ret := _m.Called(n)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(int) *mgo.Query); ok {
		r0 = rf(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// SetMaxTime provides a mock function with given fields: d
func (_m *MongoQuery) SetMaxTime(d time.Duration) *mgo.Query {
	ret := _m.Called(d)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(time.Duration) *mgo.Query); ok {
		r0 = rf(d)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Skip provides a mock function with given fields: n
func (_m *MongoQuery) Skip(n int) *mgo.Query {
	ret := _m.Called(n)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(int) *mgo.Query); ok {
		r0 = rf(n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Snapshot provides a mock function with given fields:
func (_m *MongoQuery) Snapshot() *mgo.Query {
	ret := _m.Called()

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func() *mgo.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Sort provides a mock function with given fields: fields
func (_m *MongoQuery) Sort(fields ...string) *mgo.Query {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *mgo.Query
	if rf, ok := ret.Get(0).(func(...string) *mgo.Query); ok {
		r0 = rf(fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Query)
		}
	}

	return r0
}

// Tail provides a mock function with given fields: timeout
func (_m *MongoQuery) Tail(timeout time.Duration) *mgo.Iter {
	ret := _m.Called(timeout)

	var r0 *mgo.Iter
	if rf, ok := ret.Get(0).(func(time.Duration) *mgo.Iter); ok {
		r0 = rf(timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*mgo.Iter)
		}
	}

	return r0
}
